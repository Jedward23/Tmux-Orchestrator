#!/usr/bin/env python3
"""
GitHub Issue Generator for Tmux-Orchestrator Repository
Creates comprehensive, actionable issues from test output and script validation
Specifically designed for DementedWeasel1971/Tmux-Orchestrator
"""

import json
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path


class TmuxOrchestratorIssueGenerator:
    def __init__(self):
        self.repo_info = {
            "owner": "DementedWeasel1971",
            "name": "Tmux-Orchestrator",
            "default_branch": "main"
        }
        
        self.orchestrator_issue_template = """## {issue_type}: {title}

### Component Information
- **Script/File**: `{component_file}`
- **Function/Feature**: `{component_name}`
- **Issue Type**: {issue_type}
- **Severity**: {severity}
- **First Detected**: {first_detected}

### Issue Details
```
{error_output}
```

### Code Context
```{language}
{code_context}
```

### Impact Assessment
{impact_assessment}

### Reproduction Steps
{reproduction_steps}

### Suggested Fix
{suggested_fix}

### Related Components
{related_components}

### Environment
- **Platform**: {platform} (WSL/Linux/macOS)
- **Python Version**: {python_version}
- **Tmux Version**: {tmux_version}
- **Git Branch**: {git_branch}
- **Last Working Commit**: {last_working_commit}

### Agent Assignment Recommendation
{agent_recommendation}

### Labels
{labels}

---
*Auto-generated by Issue Curator Agent for Tmux-Orchestrator*
"""

    def validate_orchestrator_components(self):
        """Validate all Tmux Orchestrator components and create issues for failures"""
        issues_created = []
        
        # Validate Python scripts
        python_scripts = [
            "tmux_utils.py",
            "scripts/generate-test-issue.py",
            "scripts/issue-relationship-tracker.py"
        ]
        
        for script in python_scripts:
            if Path(script).exists():
                issue = self._validate_python_script(script)
                if issue:
                    issues_created.append(issue)
        
        # Validate shell scripts
        shell_scripts = [
            "send-claude-message.sh",
            "schedule_with_note.sh",
            "scripts/discover-tests.sh",
            "scripts/run-issue-curator.sh"
        ]
        
        for script in shell_scripts:
            if Path(script).exists():
                issue = self._validate_shell_script(script)
                if issue:
                    issues_created.append(issue)
        
        # Validate tmux functionality
        tmux_issue = self._validate_tmux_functionality()
        if tmux_issue:
            issues_created.append(tmux_issue)
        
        # Validate GitHub integration
        gh_issue = self._validate_github_integration()
        if gh_issue:
            issues_created.append(gh_issue)
        
        return issues_created
    
    def _validate_python_script(self, script_path):
        """Validate a Python script for syntax and imports"""
        try:
            # Check syntax
            result = subprocess.run(
                ["python3", "-m", "py_compile", script_path],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_script_issue(
                    script_path,
                    "Python Syntax Error",
                    result.stderr,
                    "syntax-error",
                    "high"
                )
            
            # Check imports
            result = subprocess.run(
                ["python3", "-c", f"import ast; ast.parse(open('{script_path}').read())"],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_script_issue(
                    script_path,
                    "Python Import Error", 
                    result.stderr,
                    "import-error",
                    "medium"
                )
                
        except Exception as e:
            return self._create_script_issue(
                script_path,
                "Script Validation Failed",
                str(e),
                "validation-error", 
                "medium"
            )
        
        return None
    
    def _validate_shell_script(self, script_path):
        """Validate a shell script for syntax and executability"""
        try:
            # Check if executable
            if not Path(script_path).stat().st_mode & 0o111:
                return self._create_script_issue(
                    script_path,
                    "Script Not Executable",
                    f"Script {script_path} does not have execute permissions",
                    "permissions",
                    "medium"
                )
            
            # Check syntax
            result = subprocess.run(
                ["bash", "-n", script_path],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_script_issue(
                    script_path,
                    "Shell Script Syntax Error",
                    result.stderr,
                    "syntax-error",
                    "high"
                )
                
        except Exception as e:
            return self._create_script_issue(
                script_path,
                "Shell Script Validation Failed",
                str(e),
                "validation-error",
                "medium"
            )
        
        return None
    
    def _validate_tmux_functionality(self):
        """Check if tmux is working and sessions can be managed"""
        try:
            # Check if tmux is available
            result = subprocess.run(
                ["tmux", "-V"],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_component_issue(
                    "tmux",
                    "Tmux Not Available",
                    "Tmux command not found or not working",
                    "dependency-missing",
                    "critical"
                )
            
            # Check if we can list sessions
            result = subprocess.run(
                ["tmux", "list-sessions"],
                capture_output=True, text=True
            )
            
            # Return code 1 is OK (no sessions), anything else is an error
            if result.returncode not in [0, 1]:
                return self._create_component_issue(
                    "tmux",
                    "Tmux Session Management Failed",
                    result.stderr,
                    "tmux-error",
                    "high"
                )
                
        except Exception as e:
            return self._create_component_issue(
                "tmux",
                "Tmux Validation Failed",
                str(e),
                "validation-error",
                "high"
            )
        
        return None
    
    def _validate_github_integration(self):
        """Check GitHub CLI authentication and repository access"""
        try:
            # Check if gh is available
            result = subprocess.run(
                ["gh", "--version"],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_component_issue(
                    "github-cli",
                    "GitHub CLI Not Available",
                    "gh command not found",
                    "dependency-missing",
                    "high"
                )
            
            # Check authentication
            result = subprocess.run(
                ["gh", "auth", "status"],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_component_issue(
                    "github-cli",
                    "GitHub CLI Not Authenticated",
                    "Run 'gh auth login' to authenticate",
                    "authentication",
                    "high"
                )
            
            # Check repository access
            result = subprocess.run(
                ["gh", "repo", "view", f"{self.repo_info['owner']}/{self.repo_info['name']}"],
                capture_output=True, text=True
            )
            
            if result.returncode != 0:
                return self._create_component_issue(
                    "github-repo",
                    "Repository Access Failed",
                    result.stderr,
                    "access-denied",
                    "high"
                )
                
        except Exception as e:
            return self._create_component_issue(
                "github-cli",
                "GitHub Integration Validation Failed",
                str(e),
                "validation-error",
                "high"
            )
        
        return None
    
    def _create_script_issue(self, script_path, title, error_output, error_type, severity):
        """Create an issue for script problems"""
        return {
            "type": "Script Error",
            "title": f"{title} in {script_path}",
            "component_file": script_path,
            "component_name": Path(script_path).stem,
            "error_output": error_output,
            "error_type": error_type,
            "severity": severity
        }
    
    def _create_component_issue(self, component, title, error_output, error_type, severity):
        """Create an issue for component problems"""
        return {
            "type": "Component Error",
            "title": f"{title} - {component}",
            "component_file": component,
            "component_name": component,
            "error_output": error_output,
            "error_type": error_type,
            "severity": severity
        }

    def parse_test_failure(self, test_output, framework="python"):
        """Parse test output for orchestrator scripts"""
        # For orchestrator, we mainly validate script functionality
        return self.validate_orchestrator_components()

    def _parse_pytest_failure(self, output):
        """Parse pytest failure output"""
        failure_data = {
            "failures": [],
            "summary": ""
        }
        
        # Find FAILED lines
        failed_pattern = r'FAILED (.*?)::(\S+)(?:\[(.*?)\])? - (.*)'
        for match in re.finditer(failed_pattern, output, re.MULTILINE):
            failure = {
                "file": match.group(1),
                "test": match.group(2),
                "params": match.group(3),
                "error": match.group(4),
                "full_name": f"{match.group(1)}::{match.group(2)}"
            }
            
            # Extract stack trace
            stack_start = output.find(failure["full_name"])
            if stack_start != -1:
                stack_end = output.find("\n\n", stack_start)
                failure["stack_trace"] = output[stack_start:stack_end]
            
            failure_data["failures"].append(failure)
        
        # Extract summary
        summary_match = re.search(r'=+ (.*? failed.*?) =+', output)
        if summary_match:
            failure_data["summary"] = summary_match.group(1)
        
        return failure_data

    def _parse_jest_failure(self, output):
        """Parse Jest failure output"""
        failure_data = {
            "failures": [],
            "summary": ""
        }
        
        # Jest failure pattern
        fail_pattern = r'‚óè (.*?)\n\n(.*?)(?=\n\n|$)'
        for match in re.finditer(fail_pattern, output, re.DOTALL):
            test_path = match.group(1)
            error_details = match.group(2)
            
            failure = {
                "file": test_path.split(" ‚Ä∫ ")[0] if " ‚Ä∫ " in test_path else test_path,
                "test": test_path.split(" ‚Ä∫ ")[-1] if " ‚Ä∫ " in test_path else test_path,
                "error": error_details.strip(),
                "full_name": test_path
            }
            failure_data["failures"].append(failure)
        
        return failure_data

    def _extract_code_context(self, file_path, line_number, context_lines=5):
        """Extract code context around the failing line"""
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            
            start = max(0, line_number - context_lines - 1)
            end = min(len(lines), line_number + context_lines)
            
            context = []
            for i in range(start, end):
                marker = ">>> " if i == line_number - 1 else "    "
                context.append(f"{i+1:4d}{marker}{lines[i].rstrip()}")
            
            return "\n".join(context)
        except:
            return "Could not extract code context"

    def _find_related_issues(self, test_name, error_message):
        """Find related GitHub issues"""
        try:
            # Search for related issues
            search_terms = [
                f'"{test_name}" in:title',
                f'"{error_message[:50]}" in:body',
                'label:test-failure is:open'
            ]
            
            related = []
            for term in search_terms:
                cmd = f'gh issue list --search "{term}" --limit 5 --json number,title'
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                if result.returncode == 0 and result.stdout:
                    issues = json.loads(result.stdout)
                    for issue in issues:
                        related.append(f"- #{issue['number']}: {issue['title']}")
            
            return "\n".join(related[:5]) if related else "No related issues found"
        except:
            return "Could not search for related issues"

    def _suggest_fix(self, error_type, error_message, code_context):
        """Generate suggested fix based on error pattern"""
        suggestions = {
            "AssertionError": "Review the assertion and expected vs actual values",
            "ImportError": "Check if the module is installed and in the Python path",
            "AttributeError": "Verify the object has the expected attribute/method",
            "TypeError": "Check argument types and function signatures",
            "KeyError": "Ensure the key exists in the dictionary/object",
            "IndexError": "Verify array/list bounds and length",
            "ValueError": "Validate input data and type conversions"
        }
        
        # Extract error type
        error_class = error_type.split('.')[-1] if '.' in error_type else error_type
        
        base_suggestion = suggestions.get(error_class, "Analyze the error context and stack trace")
        
        # Add specific suggestions based on patterns
        if "None" in error_message or "NoneType" in error_message:
            base_suggestion += "\n- Add null/None checks before accessing attributes"
        if "timeout" in error_message.lower():
            base_suggestion += "\n- Increase timeout values or optimize the operation"
        if "connection" in error_message.lower():
            base_suggestion += "\n- Check network connectivity and service availability"
        
        return base_suggestion

    def generate_orchestrator_issue(self, issue_data):
        """Generate a GitHub issue for orchestrator component failures"""
        
        # Get environment information
        platform = subprocess.run(['uname', '-s'], capture_output=True, text=True).stdout.strip()
        python_version = subprocess.run(['python3', '--version'], capture_output=True, text=True).stdout.strip()
        tmux_version = subprocess.run(['tmux', '-V'], capture_output=True, text=True).stdout.strip()
        git_branch = subprocess.run(['git', 'branch', '--show-current'], capture_output=True, text=True).stdout.strip()
        
        # Determine impact and agent recommendation
        impact_assessment = self._assess_impact(issue_data)
        agent_recommendation = self._recommend_agent(issue_data)
        
        # Generate reproduction steps
        repro_steps = self._generate_reproduction_steps(issue_data)
        
        # Get related components
        related_components = self._find_related_components(issue_data)
        
        # Determine labels
        labels = self._generate_labels(issue_data)
        
        # Fill template
        issue_content = self.orchestrator_issue_template.format(
            issue_type=issue_data["type"],
            title=issue_data["title"],
            component_file=issue_data["component_file"],
            component_name=issue_data["component_name"],
            severity=issue_data["severity"],
            first_detected=datetime.now().strftime("%Y-%m-%d %H:%M UTC"),
            error_output=issue_data["error_output"],
            language="python" if issue_data["component_file"].endswith('.py') else "bash",
            code_context=self._get_component_context(issue_data["component_file"]),
            impact_assessment=impact_assessment,
            reproduction_steps=repro_steps,
            suggested_fix=self._suggest_orchestrator_fix(issue_data),
            related_components=related_components,
            platform=platform,
            python_version=python_version,
            tmux_version=tmux_version,
            git_branch=git_branch,
            last_working_commit=self._get_last_working_commit(),
            agent_recommendation=agent_recommendation,
            labels=', '.join(f'`{label}`' for label in labels)
        )
        
        return issue_content, labels
    
    def _assess_impact(self, issue_data):
        """Assess the impact of the issue on orchestrator functionality"""
        severity = issue_data["severity"]
        component = issue_data["component_file"]
        
        impact_map = {
            "critical": "üî¥ **CRITICAL**: Orchestrator cannot function",
            "high": "üü† **HIGH**: Major functionality affected", 
            "medium": "üü° **MEDIUM**: Some features may not work",
            "low": "üü¢ **LOW**: Minor impact on functionality"
        }
        
        base_impact = impact_map.get(severity, "Unknown impact")
        
        # Add component-specific impact
        if "tmux" in component:
            base_impact += "\n- Session management and agent coordination affected"
        elif "send-claude-message" in component:
            base_impact += "\n- Agent communication will fail"
        elif "schedule" in component:
            base_impact += "\n- Self-scheduling and continuity affected"
        elif "github" in component or "gh" in component:
            base_impact += "\n- Issue tracking and version control affected"
        
        return base_impact
    
    def _recommend_agent(self, issue_data):
        """Recommend which type of agent should handle this issue"""
        component = issue_data["component_file"]
        error_type = issue_data["error_type"]
        
        if error_type in ["syntax-error", "import-error"]:
            return "**Developer Agent** - Code fix required"
        elif error_type in ["permissions", "authentication"]:
            return "**DevOps Agent** - System configuration issue"
        elif error_type in ["dependency-missing"]:
            return "**DevOps Agent** - Environment setup required"
        elif "tmux" in component:
            return "**DevOps Agent** - System administration required"
        elif component.endswith('.py'):
            return "**Developer Agent** - Python expertise needed"
        elif component.endswith('.sh'):
            return "**DevOps Agent** - Shell scripting expertise needed"
        else:
            return "**Developer Agent** - General debugging required"
    
    def _generate_reproduction_steps(self, issue_data):
        """Generate specific reproduction steps for the issue"""
        component = issue_data["component_file"]
        
        if component.endswith('.py'):
            return f"""1. Navigate to project root directory
2. Run: `python3 {component}`
3. Observe the error output
4. Alternative: `python3 -m py_compile {component}` to check syntax"""
        elif component.endswith('.sh'):
            return f"""1. Navigate to project root directory
2. Check permissions: `ls -la {component}`
3. Run syntax check: `bash -n {component}`
4. Run script: `./{component}`"""
        elif component == "tmux":
            return """1. Check tmux installation: `tmux -V`
2. Try listing sessions: `tmux list-sessions`
3. Check if tmux server is responsive: `tmux info`"""
        elif component == "github-cli":
            return """1. Check gh installation: `gh --version`
2. Check authentication: `gh auth status`
3. Test repo access: `gh repo view DementedWeasel1971/Tmux-Orchestrator`"""
        else:
            return "1. Follow the error details above\n2. Check component availability\n3. Verify configuration"
    
    def _find_related_components(self, issue_data):
        """Find components related to this issue"""
        component = issue_data["component_file"]
        
        relationships = {
            "send-claude-message.sh": ["tmux_utils.py", "schedule_with_note.sh"],
            "tmux_utils.py": ["send-claude-message.sh", "run-issue-curator.sh"],
            "schedule_with_note.sh": ["send-claude-message.sh", "next_check_note.txt"],
            "github-cli": ["generate-test-issue.py", "issue-relationship-tracker.py"]
        }
        
        related = relationships.get(component, [])
        if related:
            return "\n".join(f"- `{comp}`" for comp in related)
        else:
            return "No direct dependencies identified"
    
    def _generate_labels(self, issue_data):
        """Generate appropriate labels for the issue"""
        labels = ["orchestrator", "automated"]
        
        # Add severity label
        labels.append(f"priority-{issue_data['severity']}")
        
        # Add component type labels
        if issue_data["component_file"].endswith('.py'):
            labels.append("python")
        elif issue_data["component_file"].endswith('.sh'):
            labels.append("shell-script")
        
        # Add error type labels
        error_type = issue_data["error_type"]
        if error_type == "syntax-error":
            labels.append("syntax")
        elif error_type == "permissions":
            labels.append("permissions")
        elif error_type == "authentication":
            labels.append("auth")
        elif error_type == "dependency-missing":
            labels.append("dependencies")
        
        # Add component-specific labels
        component = issue_data["component_file"]
        if "tmux" in component:
            labels.append("tmux")
        elif "github" in component or "gh" in component:
            labels.append("github")
        elif "schedule" in component:
            labels.append("scheduling")
        
        return labels
    
    def _get_component_context(self, component_file):
        """Get code context for the component"""
        try:
            if Path(component_file).exists():
                with open(component_file, 'r') as f:
                    lines = f.readlines()
                
                # For scripts, show first 20 lines
                context_lines = lines[:20]
                context = ""
                for i, line in enumerate(context_lines, 1):
                    context += f"{i:3d}  {line.rstrip()}\n"
                
                if len(lines) > 20:
                    context += f"\n... ({len(lines) - 20} more lines)"
                
                return context
        except:
            pass
        
        return f"Could not read {component_file}"
    
    def _suggest_orchestrator_fix(self, issue_data):
        """Suggest fixes specific to orchestrator components"""
        error_type = issue_data["error_type"]
        component = issue_data["component_file"]
        
        suggestions = {
            "syntax-error": "Review and fix syntax errors in the script",
            "import-error": "Check if all required modules are installed",
            "permissions": f"Run: `chmod +x {component}` to make executable",
            "authentication": "Run: `gh auth login` and follow prompts",
            "dependency-missing": "Install missing dependencies (tmux, gh, python3)",
            "tmux-error": "Restart tmux server: `tmux kill-server && tmux`",
            "validation-error": "Check component configuration and dependencies"
        }
        
        base_suggestion = suggestions.get(error_type, "Analyze error details and fix accordingly")
        
        # Add component-specific suggestions
        if component == "send-claude-message.sh":
            base_suggestion += "\n- Verify tmux session exists before sending messages\n- Check message formatting"
        elif component == "tmux_utils.py":
            base_suggestion += "\n- Ensure tmux is running and accessible\n- Check Python imports"
        elif component == "schedule_with_note.sh":
            base_suggestion += "\n- Verify target window exists\n- Check file permissions for note writing"
        
        return base_suggestion
    
    def _get_last_working_commit(self):
        """Get the last working commit hash"""
        try:
            result = subprocess.run(
                ['git', 'log', '--oneline', '-1'],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except:
            pass
        return "Unknown"

    def generate_issue(self, failure_info, project_info):
        """Generate a complete GitHub issue from failure info - legacy method"""
        # For orchestrator, redirect to orchestrator-specific method
        if isinstance(failure_info, dict) and "type" in failure_info:
            return self.generate_orchestrator_issue(failure_info)
        
        # Fallback to original logic for other test types
        test_type = "Unit"
        if "integration" in failure_info.get("test", "").lower():
            test_type = "Integration"
        elif "e2e" in failure_info.get("test", "").lower():
            test_type = "E2E"
        
        # Generate reproduction steps
        repro_steps = f"""1. Ensure test environment is set up
2. Run: `{project_info['test_command']} {failure_info['full_name']}`
3. Observe the failure with error: {failure_info['error'][:100]}...
"""
        
        # Extract line number from stack trace if possible
        line_match = re.search(r'File "([^"]+)", line (\d+)', failure_info.get('stack_trace', ''))
        code_context = "Not available"
        if line_match:
            file_path = line_match.group(1)
            line_num = int(line_match.group(2))
            code_context = self._extract_code_context(file_path, line_num)
        
        # Find related issues
        related_issues = self._find_related_issues(
            failure_info['test'],
            failure_info['error']
        )
        
        # Generate suggested fix
        suggested_fix = self._suggest_fix(
            failure_info.get('error_type', 'Unknown'),
            failure_info['error'],
            code_context
        )
        
        # Determine labels
        labels = ["test-failure", "automated"]
        if test_type == "E2E":
            labels.append("e2e")
        if "timeout" in failure_info['error'].lower():
            labels.append("performance")
        if any(word in failure_info['error'].lower() for word in ['auth', 'permission', 'token']):
            labels.append("security")
        
        # Fill template
        issue_content = self.issue_template.format(
            title=f"{failure_info['test']} - {failure_info['error'][:50]}",
            test_file=failure_info['file'],
            test_name=failure_info['test'],
            test_type=test_type,
            first_failed=datetime.now().strftime("%Y-%m-%d %H:%M UTC"),
            failure_rate="100% (1/1 runs)",  # Would track this over time
            error_output=failure_info.get('stack_trace', failure_info['error']),
            language=project_info.get('language', 'python'),
            code_context=code_context,
            related_issues=related_issues,
            reproduction_steps=repro_steps,
            suggested_fix=suggested_fix,
            os_info=subprocess.run(['uname', '-a'], capture_output=True, text=True).stdout.strip(),
            language_version=project_info.get('language_version', 'Unknown'),
            test_framework=project_info.get('framework', 'Unknown'),
            last_working_commit="Unknown (implement git bisect for this)",
            labels=', '.join(f'`{label}`' for label in labels)
        )
        
        return issue_content, labels

    def create_github_issue(self, title, body, labels):
        """Create the issue using GitHub CLI"""
        # Save body to temp file (handles quotes better)
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
            f.write(body)
            temp_file = f.name
        
        try:
            cmd = [
                'gh', 'issue', 'create',
                '--title', title,
                '--body-file', temp_file,
                '--label', ','.join(labels)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                print(f"‚úÖ Created issue: {result.stdout.strip()}")
                return result.stdout.strip()
            else:
                print(f"‚ùå Failed to create issue: {result.stderr}")
                return None
        finally:
            Path(temp_file).unlink()


def main():
    """Main function - validate Tmux Orchestrator components"""
    generator = TmuxOrchestratorIssueGenerator()
    
    print("üîç Validating Tmux Orchestrator Components...")
    print("=" * 60)
    
    # Validate all components
    issues = generator.validate_orchestrator_components()
    
    if not issues:
        print("‚úÖ All components validated successfully!")
        print("No issues found in orchestrator components.")
        return
    
    print(f"‚ùå Found {len(issues)} issues:")
    print()
    
    created_issues = []
    
    for issue_data in issues:
        print(f"Issue: {issue_data['title']}")
        print(f"Severity: {issue_data['severity']}")
        print(f"Component: {issue_data['component_file']}")
        
        # Generate issue content
        issue_content, labels = generator.generate_orchestrator_issue(issue_data)
        
        # Ask if we should create the issue
        response = input(f"\nCreate GitHub issue for '{issue_data['title']}'? (y/n): ")
        if response.lower() == 'y':
            title = f"[{issue_data['severity'].upper()}] {issue_data['title']}"
            issue_url = generator.create_github_issue(title, issue_content, labels)
            if issue_url:
                created_issues.append(issue_url)
        
        print("-" * 40)
    
    if created_issues:
        print(f"\n‚úÖ Created {len(created_issues)} GitHub issues:")
        for url in created_issues:
            print(f"  - {url}")
    else:
        print("\nNo issues were created.")
    
    # Example orchestrator issue format (commented out)
    """
    # Example for testing issue generation
    sample_issue = {
        "type": "Script Error",
        "title": "Python Syntax Error in send-claude-message.sh",
        "component_file": "send-claude-message.sh",
        "component_name": "send-claude-message",
        "error_output": "bash: line 15: syntax error near unexpected token",
        "error_type": "syntax-error",
        "severity": "high"
    }
    
    issue_content, labels = generator.generate_orchestrator_issue(sample_issue)
    print("\nExample Issue Content:")
    print("=" * 80)
    print(issue_content)
    """
    
    project_info = {
        "language": "python",
        "language_version": "3.9.0",
        "framework": "pytest",
        "test_command": "pytest -xvs"
    }
    
    issue_body, labels = generator.generate_issue(sample_failure, project_info)
    
    print("Generated Issue:")
    print("=" * 80)
    print(issue_body)
    print("=" * 80)
    print(f"Labels: {labels}")


if __name__ == "__main__":
    main()